<!-- PublicViewJavascript.html -->
<script>
    const PUBLIC_DEBUG = true;
    function logPublicDebug(...args) {
        if (PUBLIC_DEBUG) {
            console.log("[PUBLIC DEBUG]", ...args);
        }
    }
    function showLoading() {
        logPublicDebug("showLoading called");
        const loadingDiv = document.getElementById("loading");
        if (loadingDiv) loadingDiv.style.display = "flex";
        const messageDiv = document.getElementById("message");
        if (messageDiv) {
            messageDiv.textContent = "";
            messageDiv.className = "message";
            messageDiv.style.display = 'none';
        }
    }
    function hideLoading() {
        logPublicDebug("hideLoading called");
        const loadingDiv = document.getElementById("loading");
        if (loadingDiv) loadingDiv.style.display = "none";
    }
    function displayMessage(text, type = 'info') {
        const messageDiv = document.getElementById("message");
        logPublicDebug(`displayMessage called with text: "${text}", type: "${type}"`);
        if (messageDiv) {
            messageDiv.textContent = text;
            messageDiv.className = "message " + type;
            const show = (text && String(text).trim() !== '');
            messageDiv.style.display = show ? 'block' : 'none';
            if (show && (type === 'error' || type === 'success')) {
                try { messageDiv.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
                catch (e) { messageDiv.scrollIntoView(); }
            }
        } else {
            console.warn("Element with ID 'message' not found.");
        }
    }
    function formatYYYYMMDDToDDMMYYYY(dateString) {
        if (!dateString || typeof dateString !== 'string') return dateString;
        const parts = dateString.split('-');
        if (parts.length === 3) {
            if (!/^\d{4}$/.test(parts[0]) || !/^\d{2}$/.test(parts[1]) || !/^\d{2}$/.test(parts[2])) return dateString;
            const year = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10);
            const day = parseInt(parts[2], 10);
            if (year > 1000 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                const dateObj = new Date(year, month - 1, day);
                if (!isNaN(dateObj.getTime()) && dateObj.getFullYear() === year && (dateObj.getMonth() + 1) === month && dateObj.getDate() === day) {
                    const formattedDay = String(day).padStart(2, '0');
                    const formattedMonth = String(month).padStart(2, '0');
                    return `${formattedDay}/${formattedMonth}/${year}`;
                }
            }
        }
        return dateString;
    }
    function populateDropdown(selectId, optionsArray, defaultText = "-- Selecione --") {
        logPublicDebug(`populateDropdown called for ID: '${selectId}'`);
        const selectElement = document.getElementById(selectId);
        if (!selectElement) { console.warn(`Dropdown '${selectId}' not found.`); return; }
        selectElement.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = "";
        defaultOption.textContent = defaultText;
        defaultOption.disabled = true;
        defaultOption.selected = true;
        selectElement.appendChild(defaultOption);
        if (optionsArray && Array.isArray(optionsArray)) {
            optionsArray.forEach(optionItem => {
                const value = typeof optionItem === 'object' && optionItem !== null && optionItem.hasOwnProperty('value') ? String(optionItem.value).trim() : String(optionItem).trim();
                const text = typeof optionItem === 'object' && optionItem !== null && optionItem.hasOwnProperty('text') ? String(optionItem.text).trim() : value;
                if (value !== '') {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = text;
                    selectElement.appendChild(option);
                }
            });
        }
        selectElement.disabled = false;
        selectElement.selectedIndex = 0;
        logPublicDebug(`Finished populating '${selectId}'. Total options: ${selectElement.options.length}`);
    }
    function formatPublicCellContent(mainContent, status) {
        const statusText = status && status.trim() !== '' ? status.trim() : 'Status Desconhecido';
        let statusClass = 'status-default';
        if (status === 'Disponivel') statusClass = 'status-disponivel';
        else if (status === 'Reposicao Agendada') statusClass = 'status-reposicao';
        else if (status === 'Substituicao Agendada') statusClass = 'status-substituicao';
        const statusSpan = `<span class="slot-status ${statusClass}">(${statusText})</span>`;
        if (mainContent && mainContent.trim() !== '') {
            const mainContentDiv = `<div class="slot-main-content">${mainContent.trim()}</div>`;
            return `${mainContentDiv}${statusSpan}`;
        } else {
            return statusSpan;
        }
    }
    function loadWeekFilterOptions() {
        logPublicDebug("loadWeekFilterOptions called");
        showLoading();
        google.script.run
            .withSuccessHandler(onWeekFilterOptionsLoaded)
            .withFailureHandler(onWeekFilterOptionsFailed)
            .getScheduleViewFilters();
    }
    function onWeekFilterOptionsLoaded(jsonStringResponse) {
        hideLoading();
        logPublicDebug("onWeekFilterOptionsLoaded received response.");
        let response;
        try {
            response = JSON.parse(jsonStringResponse);
            logPublicDebug("Parsed week filter options response:", response);
        } catch (e) {
            console.error("Erro ao parsear JSON de filtros (semanas):", e, jsonStringResponse);
            displayMessage('Erro ao processar opções de semana.', 'error');
            populateDropdown('week-filter', [], '-- Erro Semanas --');
            return;
        }
        if (!response || !response.success || !response.data || !Array.isArray(response.data.weekStartDates)) {
            const errorMessage = (response && response.message) ? response.message : 'Erro desconhecido ao carregar semanas.';
            console.error("Falha ao carregar semanas:", errorMessage, response);
            displayMessage(errorMessage, 'error');
            populateDropdown('week-filter', [], '-- Erro Semanas --');
            return;
        }
        const weeksForDropdown = response.data.weekStartDates.map(dateString => {
            const formattedDate = formatYYYYMMDDToDDMMYYYY(dateString);
            const displayText = (formattedDate !== dateString) ? `Semana de ${formattedDate}` : dateString;
            return { value: dateString, text: displayText };
        }).filter(item => item.value);
        populateDropdown('week-filter', weeksForDropdown, '-- Selecione a Semana --');
        displayMessage('Selecione a semana desejada.', 'info');
        try {
            const today = new Date(); today.setHours(0, 0, 0, 0);
            const currentDayOfWeek = today.getDay();
            const mondayOfCurrentWeek = new Date(today);
            const daysToSubtract = (currentDayOfWeek === 0) ? 6 : currentDayOfWeek - 1;
            mondayOfCurrentWeek.setDate(today.getDate() - daysToSubtract);
            const year = mondayOfCurrentWeek.getFullYear();
            const month = String(mondayOfCurrentWeek.getMonth() + 1).padStart(2, '0');
            const day = String(mondayOfCurrentWeek.getDate()).padStart(2, '0');
            const currentWeekString = `${year}-${month}-${day}`;
            logPublicDebug("Calculated current week start date:", currentWeekString);
            const weekSelect = document.getElementById('week-filter');
            if (weekSelect) {
                let found = false;
                for (let i = 0; i < weekSelect.options.length; i++) {
                    if (weekSelect.options[i].value === currentWeekString) {
                        weekSelect.selectedIndex = i;
                        found = true;
                        logPublicDebug("Current week selected in dropdown.");
                        break;
                    }
                }
                if (!found && weekSelect.options.length > 1) {
                    weekSelect.selectedIndex = 1;
                    logPublicDebug("Current week not found, selected first available week.");
                }
            }
        } catch (dateError) {
            console.error("Error calculating/selecting current week:", dateError);
        }
    }
    function onWeekFilterOptionsFailed(error) {
        hideLoading();
        console.error("Erro na comunicação ao carregar semanas:", error);
        displayMessage('Erro na comunicação com o servidor ao carregar semanas: ' + error.message, 'error');
        populateDropdown('week-filter', [], '-- Erro Semanas --');
    }
    function loadPublicSchedules() {
        logPublicDebug("loadPublicSchedules called");
        const weekFilter = document.getElementById('week-filter');
        const allSchedulesContainer = document.getElementById('all-schedules-container');
        displayMessage('');
        if (allSchedulesContainer) {
            allSchedulesContainer.innerHTML = '<p class="info-message">Carregando horários...</p>';
        } else {
            console.error("Container 'all-schedules-container' not found!");
            displayMessage("Erro interno: Container principal não encontrado.", "error");
            return;
        }
        const selectedWeek = weekFilter ? weekFilter.value : '';
        if (!selectedWeek) {
            logPublicDebug("Validation failed: Week not selected.");
            displayMessage('Por favor, selecione a Semana.', 'error');
            if (allSchedulesContainer) allSchedulesContainer.innerHTML = '<p class="info-message">Selecione a Semana e clique em "Buscar Horários".</p>';
            return;
        }
        logPublicDebug(`Fetching public schedules for week: ${selectedWeek}`);
        showLoading();
        google.script.run
            .withSuccessHandler(onPublicSchedulesLoaded)
            .withFailureHandler(onPublicSchedulesLoadFailed)
            .getPublicScheduleInstances(selectedWeek);
    }
    function onPublicSchedulesLoaded(jsonStringResponse) {
        hideLoading();
        logPublicDebug("onPublicSchedulesLoaded received response.");
        const allSchedulesContainer = document.getElementById('all-schedules-container');
        if (!allSchedulesContainer) { console.error("Container 'all-schedules-container' not found!"); return; }
        allSchedulesContainer.innerHTML = '';
        let response;
        try {
            response = JSON.parse(jsonStringResponse);
            logPublicDebug("Parsed public schedules response:", response);
        } catch (e) {
            console.error("Erro ao parsear JSON de horários públicos:", e, jsonStringResponse);
            displayMessage('Erro ao processar dados de horários.', 'error');
            allSchedulesContainer.innerHTML = '<p class="error-message">Erro ao carregar horários.</p>';
            return;
        }
        if (!response || !response.success) {
            const errorMessage = (response && response.message) ? response.message : 'Erro desconhecido ao carregar horários públicos.';
            console.error("Falha ao carregar horários públicos:", errorMessage, response);
            displayMessage(errorMessage, 'error');
            allSchedulesContainer.innerHTML = `<p class="error-message">${errorMessage}</p>`;
            return;
        }
        const schedulesByTurma = response.data;
        if (!schedulesByTurma || typeof schedulesByTurma !== 'object' || Object.keys(schedulesByTurma).length === 0) {
            logPublicDebug("No schedule data found for any turma.");
            displayMessage(response.message || 'Nenhum horário encontrado para a semana selecionada.', 'info');
            allSchedulesContainer.innerHTML = '<p class="info-message">Nenhum horário encontrado para a semana selecionada.</p>';
            return;
        }
        displayMessage(response.message || 'Horários carregados com sucesso.', 'success');
        logPublicDebug(`Rendering schedules for ${Object.keys(schedulesByTurma).length} turmas.`);
        const sortedTurmas = Object.keys(schedulesByTurma).sort((a, b) => a.localeCompare(b));
        sortedTurmas.forEach(turmaName => {
            const turmaSlots = schedulesByTurma[turmaName];
            if (Array.isArray(turmaSlots) && turmaSlots.length > 0) {
                logPublicDebug(`Rendering schedule for Turma: ${turmaName} (${turmaSlots.length} slots)`);
                const turmaContainer = document.createElement('div');
                turmaContainer.classList.add('turma-schedule-container');
                const title = document.createElement('h3');
                title.classList.add('turma-title');
                title.textContent = `Turma: ${turmaName}`;
                turmaContainer.appendChild(title);
                const gridContainer = document.createElement('div');
                gridContainer.classList.add('schedule-container');
                renderPublicScheduleTable(turmaSlots, gridContainer);
                turmaContainer.appendChild(gridContainer);
                allSchedulesContainer.appendChild(turmaContainer);
            } else {
                logPublicDebug(`Skipping empty or invalid slot data for Turma: ${turmaName}`);
            }
        });
        logPublicDebug("Finished rendering all turma schedules.");
    }
    function onPublicSchedulesLoadFailed(error) {
        hideLoading();
        console.error("Erro na comunicação ao carregar horários públicos:", error);
        displayMessage('Erro na comunicação com o servidor ao buscar horários: ' + error.message, 'error');
        const allSchedulesContainer = document.getElementById('all-schedules-container');
        if (allSchedulesContainer) {
            allSchedulesContainer.innerHTML = '<p class="error-message">Erro ao carregar horários.</p>';
        }
    }
    function renderPublicScheduleTable(slots, containerElement) {
        logPublicDebug("renderPublicScheduleTable called");
        const daysOfWeek = ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
        const dayIndexMap = { 'Segunda': 0, 'Terça': 1, 'Quarta': 2, 'Quinta': 3, 'Sexta': 4, 'Sábado': 5 };
        const gridData = {};
        const uniqueHours = new Set();
        slots.forEach(slot => {
            if (slot && slot.diaSemana && slot.horaInicio) {
                const dayIndex = dayIndexMap[slot.diaSemana];
                if (dayIndex !== undefined) {
                    if (!gridData[dayIndex]) gridData[dayIndex] = {};
                    gridData[dayIndex][slot.horaInicio] = slot;
                    uniqueHours.add(slot.horaInicio);
                } else { console.warn("Slot com dia da semana inválido:", slot); }
            } else { console.warn("Slot inválido/incompleto recebido:", slot); }
        });
        const sortedHours = Array.from(uniqueHours).sort((a, b) => a.localeCompare(b));
        const table = document.createElement('table');
        table.classList.add('schedule-grid-table');
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        headerRow.insertCell().outerHTML = "<th></th>";
        daysOfWeek.forEach(day => { headerRow.insertCell().outerHTML = `<th>${day}</th>`; });
        const tbody = table.createTBody();
        sortedHours.forEach(hour => {
            const row = tbody.insertRow();
            const hourCell = row.insertCell();
            hourCell.textContent = hour;
            hourCell.classList.add('hour-cell');
            daysOfWeek.forEach(day => {
                const dayIndex = dayIndexMap[day];
                const cell = row.insertCell();
                cell.classList.add('slot-cell');
                const slot = gridData[dayIndex] ? gridData[dayIndex][hour] : null;
                if (slot) {
                    let mainContent = '';
                    let cellClasses = [];
                    let statusToDisplay = slot.statusOcupacao;
                    const disciplina = slot.disciplinaParaExibir || '';
                    const professor = slot.professorParaExibir || '';
                    const profOriginalBooking = slot.professorOriginalNaReserva || '';
                    const profOriginalInstance = slot.professorPrincipal || '';
                    const professoresAusentesString = slot.professoresAusentes || '';
                    const firstWordDiscipline = disciplina.split(' ')[0] || 'Aula';
                    if (slot.statusOcupacao === STATUS_OCUPACAO.DISPONIVEL) {
                        if (slot.tipoOriginal === TIPOS_HORARIO.FIXO) {
                            cellClasses.push('slot-available', 'slot-fixo');
                            mainContent = `${firstWordDiscipline} - ${formatPublicProfessorList(professor, professoresAusentesString) || 'N/D'}`;
                            statusToDisplay = null;
                        } else {
                            cell.classList.add('slot-empty');
                            return;
                        }
                    } else if (slot.statusOcupacao === STATUS_OCUPACAO.REPOSICAO_AGENDADA) {
                        cellClasses.push('slot-booked-public', 'slot-reposicao');
                        mainContent = `${firstWordDiscipline} - ${formatPublicProfessorList(professor, '')}`;
                    } else if (slot.statusOcupacao === STATUS_OCUPACAO.SUBSTITUICAO_AGENDADA) {
                        cellClasses.push('slot-booked-public', 'slot-substituicao');
                        let profText = formatPublicProfessorList(professor, professoresAusentesString);
                        const originalToShow = profOriginalBooking || profOriginalInstance;
                        if (originalToShow && originalToShow !== professor) {
                            let formattedOriginal = formatPublicProfessorList(originalToShow, professoresAusentesString, true);
                            profText = `${profText} (Orig: ${formattedOriginal})`;
                        }
                        mainContent = `${firstWordDiscipline} - ${profText}`;
                    } else {
                        cellClasses.push('slot-unknown-status');
                        mainContent = `${firstWordDiscipline} - ${formatPublicProfessorList(professor, professoresAusentesString)}`;
                        console.warn("Unexpected slot status found in public view render:", slot.statusOcupacao, slot);
                    }
                    cell.classList.add(...cellClasses);
                    cell.innerHTML = formatPublicCellContent(mainContent, statusToDisplay);
                    let tooltipText = `Data: ${slot.data}\nHora: ${slot.horaInicio}\nTipo Original: ${slot.tipoOriginal}\nStatus: ${slot.statusOcupacao}`;
                    if (professoresAusentesString) {
                        tooltipText += `\nAusentes: ${professoresAusentesString}`;
                    }
                    cell.title = tooltipText;
                } else {
                    cell.classList.add('slot-empty');
                }
            });
        });
        containerElement.appendChild(table);
        logPublicDebug("Finished rendering single public schedule table.");
    }
    function formatPublicProfessorList(profString, absentString, isOriginal = false) {
        if (!profString) return isOriginal ? '-' : 'N/D';
        const professors = profString.split(',').map(p => p.trim()).filter(p => p);
        const absents = (absentString || '').split(',').map(p => p.trim()).filter(p => p);
        return professors.map(prof => {
            if (absents.includes(prof)) {
                return `<span class="absent-professor" title="${prof} - Ausente">${prof}</span>`;
            }
            return prof;
        }).join(', ');
    }
    function formatPublicCellContent(mainContentFormattedHtml, status) {
        let statusSpanHtml = '';
        if (status && String(status).trim() !== '') {
            const statusText = status.trim();
            let statusClass = 'status-default';
            if (status === STATUS_OCUPACAO.DISPONIVEL) statusClass = 'status-disponivel';
            else if (status === STATUS_OCUPACAO.REPOSICAO_AGENDADA) statusClass = 'status-reposicao';
            else if (status === STATUS_OCUPACAO.SUBSTITUICAO_AGENDADA) statusClass = 'status-substituicao';
            statusSpanHtml = `<span class="slot-status ${statusClass}">(${statusText})</span>`;
        }
        if (mainContentFormattedHtml && mainContentFormattedHtml.trim() !== '') {
            const mainContentDiv = `<div class="slot-main-content">${mainContentFormattedHtml.trim()}</div>`;
            return `${mainContentDiv}${statusSpanHtml}`;
        } else {
            return statusSpanHtml;
        }
    }
    const STATUS_OCUPACAO = Object.freeze({
        DISPONIVEL: 'Disponivel',
        REPOSICAO_AGENDADA: 'Reposicao Agendada',
        SUBSTITUICAO_AGENDADA: 'Substituicao Agendada'
    });
    const TIPOS_HORARIO = Object.freeze({
        FIXO: 'Fixo',
        VAGO: 'Vago'
    });
    document.addEventListener('DOMContentLoaded', function () {
        logPublicDebug("PublicView DOM loaded. Loading week filter options.");
        loadWeekFilterOptions();
    });
</script>